\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsfonts, amssymb}

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{natbib}
%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations



\usepackage{includes}
\usepackage{todonotes}
\usepackage{iris}
\usepackage{xcolor}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{mathrsfs}
\usepackage{placeins}
\usepackage[inline]{enumitem}
\usepackage{rotating}
\usepackage{multirow}

%% Other packages

% for multi-file teX projects
\usepackage{standalone}
\usepackage{import}

%% For clever references: \cref{...}
\usepackage[capitalize]{cleveref}

%% more fonts
\usepackage{ dsfont }

%% proof trees
\usepackage{bussproofs}

%% for wrapping text around figures
\usepackage{wrapfig}

\author{Maxime Legoupil}
\title{Certifying MSWasm in Coq}
\date{\today}

\input{macros}
\hyphenation{WebAssembly}

\begin{document}



%
% Add assumptions we made on HandleBytes
% Proofmode
% Example with stacks in segment-memory
%

\maketitle

MSWasm \cite{mswasm} is a proposal for an extension of WebAssembly \cite{wasm} with
a simple form of capabilities \cite{capabilities}. In this document, we describe \irismswasm,
an effort to describe and mechanize proofs for this proposed extension in the Coq proof assistant,
building on \iriswasm \cite{iriswasm}, a previous mechanization of WebAssembly. In the following, all references to MSWasm mean the work of \citet{mswasm}, all references to \iriswasm mean the work of \citet{iriswasm}, and all references to \irismswasm mean my current ongoing work.

In this document, we first describe the idea behind the operational semantics of MSWasm, then how details about the implementation of the segment were implemented in \irismswasm, and finally we give an overview of the structure of \irismswasm, to help the interested reader to locate where to find the code for everything described in this document.

\section{Updating the operational semantics}

The proposal of \citet{mswasm} is to add a second kind of memory to WebAssembly, called
a \emph{segment}. Where the heap of WebAssembly is an array of raw bytes that is accessed to by
the \xxWload and \xxWstore instructions, using normal \xxWithirtytwo integers, the segment
is an array of tagged bytes that is accessed to by the \xxWsegload and \xxWsegstore instructions,
using a \emph{handle}. Handles are a new value type (in addition to the four that WebAssembly
already has, namely \xxWithirtytwo, \xxWisixtyfour, \xxWfthirtytwo and \xxWfsixtyfour),
defined as a record:

\[ \xxWhandle := \{ \xxWbase : \xxCN; \quad \xxWoffset : \xxCN;\quad \xxWbound : \xxCN;\quad \xxWvalid : \xxCbool;\quad \xxWid : \xxCN \} \]

When reading or writing using the \xxWsegload and \xxWsegstore operations, dynamic checks ensure that the address given by \( \xxWbase + \xxWoffset \) is between \xxWbase and \xxWbound, that the \xxWvalid tag is \xxCtrue, and that the handle is live, using its identifier \xxWid (we will come back to how this last check is performed).
Provided all these checks succeed, the segment is read or written to at address \( \xxWbase + \xxWoffset \). The only subtlelty pertains to reading and writing handles, where extra checks are performed. The bytes in a segment are tagged as either \xxWNumeric or \xxWHandle, to forbid interpreting as a handle bytes that where not originally a handle (reading a handle from a memory location that contains even a single byte tagged as \xxWNumeric sets the \xxWvalid field of the resulting handle to \xxCfalse). Checks are also made to ensure that reading and writing handles always occurs from offsets that are aligned.

As is custom when working with handles, one can change a handle's bounds using a \xxWslice instruction and perform pointer arithmetics using a \xxWhandleadd instruction. Lastly, handles can be obtained by calling a \xxWsegalloc instruction and freed using a \xxWsegfree instruction. \citet{mswasm} do not go into much detail into how these should be implemented, stating that the details are irrelevant as long as some unspecified properties hold. They only mention \emph{allocators}, an opaque object such that two operations \xxsalloc{T}{A}{a}{n}{n_{id}}{T'}{A'} and \xxsfree{T}{A}{a}{n_{id}}{T'}{A'} allocate and free segments with \xxWid \( n_{id} \) at address \( a \), modifying the segment \( T \) and the allocator \( A \). The allocation also takes an extra argument \( n \) corresponding to the size of the allocated handle. We will come back to how these two operations where implemented in \irismswasm.

In MSWasm \cite{mswasm}, the program store is augmented from having just a heap memory to now also having a segment and an allocator. In actual WebAssembly, however, the store contains not one heap memory but a list of heap memories, as several modules could instantiate memories and these are all kept in the store. \citet{mswasm} seems to only address the case where a single module runs and where the store can be limited to one heap memory. In the case of the segments, instead of generalizing one memory to a list of memories like we would for the heap memory, we keep one single segment and one single allocator even in the general case where several modules might be running. In other words, all modules share the same segment memory, which is completely safe given the guarantees provided by the usage of handles.


MSWasm defines new operational semantics rules for \xxWsegload, \xxWsegstore, \xxWslice, \xxWhandleadd, \xxWsegalloc and \xxWsegfree. Unlike the already existing WebAssembly rules, these new rules all are decorated with a \emph{memory event} that indicate where reads, writes, allocations, frees and fails of dynamic checks occur. This makes program executions decorated with a trace.



Since \iriswasm \cite{iriswasm} does not use memory events, the operation semantics they defined had to be adjusted. Where \iriswasm defines two inductives properties \[ \tt reduce\_simple~es~es' \] and \[ \tt reduce~s~f~es~s'~f'~es' \] \irismswasm defines 3: \[ \tt reduce\_simple~es~es' \] corresponding to \iriswasm's {\tt reduce\_simple}, \[ \tt reduce\_silent~s~f~es~s'~f'~es' \] which corresponds to the \iriswasm's \( \tt reduce \), and \[ \tt reduce~s~f~es~me~s'~f'~es' \] which contains the new rules that produce memory events. The names of the inductive cases for {\tt reduce\_simple} start with {\tt rs\_} (e.g. {\tt rs\_binop}), the cases for {\tt reduce\_silent} start with {\tt r\_} (to mimic the cases in \iriswasm's {\tt reduce}, e.g. {\tt r\_call}), and the cases for {\tt reduce} start with {\tt rm\_} (e.g. {\tt rm\_segload}).


\irismswasm's {\tt reduce\_simple} is almost identical to \iriswasm's, with just new rules for \xxWhandleadd and \xxWslice, that do not produce a memory event. Just like in \iriswasm, the first case of {\tt reduce\_silent} is \[ \tt r\_simple:~forall~e~e'~s~f,~reduce\_simple~e~e'\to reduce\_silent~s~f~e~s~f~e' \] and all the cases of {\tt reduce\_silent} are exactly those of \iriswasm's {\tt reduce}, minus {\tt r\_label} and {\tt r\_local}. Finally, \irismswasm's {\tt reduce} also has a case that embeds {\tt reduce\_silent} (adding the silent \xxCMEempty memory event). The other cases define the rules for \xxWsegload, \xxWsegstore, \xxWsegalloc and \xxWsegfree, as well as cases {\tt rm\_label} and {\tt rm\_local} that correspond to \iriswasm's {\tt r\_label} and {\tt r\_local}.

The implementation of the rules of MSWasm follow precisely the ones defined by \citet{mswasm}, the only thing remaining to implement is the meaning of \xxsalloc{T}{A}{a}{n}{n_{id}}{T'}{A'}, \xxsfree{T}{A}{a}{n_{id}}{T'}{A'}, as well as the meaning of \( n_{id}\in A \), that is one of the dynamic checks when reading and writing from the segment, to check that the segment with \xxWid \( n_{id} \) is live.

\section{Defining the segment in Coq}

For the most part, defining the segment mimics \iriswasm's definition of the heap memory, i.e. we distinguish the type {\tt segment\_list} that is a record with one field that contains an array of bytes (represented by a Coq list), and the type {\tt segment}, a record whose two field are a {\tt segment\_list} and an optional maximal size that can be set to restrict the always-present maximal size dictated by the architecture.

Apart from minor differences like the fact that the segment bytes are tagged, the biggest difference is the presence of the Allocator object, that keeps track of the areas of memory that have been allocated, and allows for allocation and freeing of handle via usage of the \xxWsegalloc and \xxWsegfree instructions.

The Allocator is implemented as a list of allocated handles. For every handle, we keep track of its \xxWid, its base address and its original length. Concretely, an Allocator is the following record type:
\[ \tt Allocator := \{ Allocated : list (N * N * N) \} \]

Given this, \( n_{id}\in A \) is defined as the existence of an entry \( (n_{id}, -, -) \) in \( A \), as captured by the Coq Proposition {\tt isAlloc}.

We can now define an inductive proposition corresponding to \xxsalloc{T}{A}{a}{n}{n_{id}}{T'}{A'}, which holds when:
\begin{itemize}
\item The newly allocated handle is in bounds in \( T' \)
\item The \xxWid \( n_{id} \) is free in \( A \)
\item The newly allocated handle does not overlap with any handle already allocated in \( A \)
\item \( T \) and \( T' \) differ only on the newly allocated hande, which is zeroed out in \( T' \)
\item \( A' \) is \( A \) with the newly allocated handle added
\item Some extra requirements pertaining to the total length of \( T' \) being lower than the maximum value (dictated either by a user-set limit or the architecture)
\end{itemize}
The inductive proposition is written so as to allow both allocating a new handle inside the segment \( T \) if space is available, or grow \( T \) dynamically to gain more space, as long as no condition of maximum size is violated. When calling \xxWsegalloc, the programmer only specifies the size \( n \) of the allocated handle, and any address \( a \) and \xxWid \( n_{id} \) together with any \( T' \) and \( A' \) that satisfies the properties above is allowed. The operational semantics of \xxWsegalloc can also nondeterministically fail to account for the possibility of an Out-of-memory.

\iriswasm also defines an interpreter for WebAssembly. Here, a strategy must be adopted for allocation. For simplicity, the strategy \irismswasm uses is to simply always grow the segment when possible and fail otherwise. In other words, no effort is ever made to check if space is available in the segment.

For \xxsfree{T}{A}{a}{n_{id}}{T'}{A'}, we define similarly an inductive proposition that holds when:
\begin{itemize}
\item The handle \xxWid \( n_{id} \) is present in \( A \) and its associated address is \( a \)
\item \( A' \) is \( A \) without the entry for \( n_{id} \)
\item \( T = T' \)
\end{itemize}
In the operational semantics rule for \xxWsegfree, the instruction takes one handle as an argument. To stay close to the MSWasm semantics \cite{mswasm}, we enforce that the \xxWoffset must be 0, the \xxWbase must be the one present in \( A \) (i.e. one cannot free a handle if one has changed the value off its \xxWbase via use of the \xxWslice instruction), and the \xxWvalid tag must be \xxCtrue. 





\section{Structure of \irismswasm}

\irismswasm is structured exactly like \iriswasm: the datatypes (including {\tt segment} and the updated version of the {\tt store}) are defined in {\tt datatypes.v}, a file which depends on {\tt segment\_list.v} where basic segment operations are defined (mirroring {\tt memory\_list.v} where basic operations on the heap memory are defined in \iriswasm). {\tt operations.v} contains a number of helper-functions to manipulate the datatypes, including functions that read and write from the segment ({\tt read\_segbytes}, {\tt segload}, {\tt write\_segbytes} and {\tt segstore} all mirror the functions {\tt read\_bytes}, {\tt load}, {\tt write\_bytes} and {\tt store} from \iriswasm) as well as the definitions of the inductive properties {\tt salloc} and {\tt sfree}. {\tt opsem.v} contains the operational semantics rules, and {\tt typing.v} contains the code pertaining to typing MSWasm code.

The rest of the files mostly contain tools like an interpreter or a binary format represntation, or lemmas pertaining to how the operational semantics or the aforementioned tools behave. These have been updated to take into account the new operational semantics.

Adapting the proofs of all lemmas of \iriswasm is done in most cases by simply mirroring what happens for the heap memory.

One difficulty is that we now have a condition we would like the WebAssembly state to follow at all times: the handles listed in the Allocator should be in-bounds in the segment they live in. In some proofs, like the proof of soundness of the interpreter, it now becomes necessary to add this as an invariant and prove it is maintained at every step of the operational semantics.


\bibliography{irismswasm}
\end{document}
