\usepackage{listings,comment}
\usepackage{amsfonts,amsmath,stmaryrd}
\PassOptionsToPackage{obeyspaces}{url}
\usepackage{tikz,pgffor,mathtools}
\usetikzlibrary{calc,fadings,decorations.pathreplacing,arrows,shapes,matrix,
chains,fit,matrix,decorations.pathmorphing}
\usepackage[tikz]{mdframed}
\usepackage{mathpartir,pftools}
\usepackage{stackengine}
\usepackage{tabularx}
\usepackage{xspace}

% \newtheorem{remark}[theorem]{Remark}
% \newtheorem{definition}{Definition}[section]
% \newtheorem{theorem}[definition]{Theorem}
% \newtheorem{lemma}[definition]{Lemma}
% \newtheorem{fact}[definition]{Fact}
\usepackage[inline]{enumitem}

\newcommand{\important}[1]{
        \begin{mdframed}[linecolor=red,roundcorner=4pt,linewidth=2pt]
        #1
        \end{mdframed}}

\renewcommand{\lstlanguagefiles}{lstlang0.sty,lstlang1.sty,lstlang2.sty,lstlang3.sty,lstcoq.tex}
\lstdefinestyle{CoqStyle}{
  keepspaces,
  language=coq,
  morekeywords=[2]{rec,ref},
  basewidth={0.50em,0.37em},
  showspaces=false,
  showstringspaces=false,
  mathescape=true,
  basicstyle=\footnotesize\ttfamily,
  % backgroundcolor=\color[rgb]{0.85,0.85,0.85},
  frame=single,
  framerule=0pt,
  xleftmargin=\fboxsep,
  xrightmargin=\fboxsep,
  literate=
         {≤}{\(\le\)}1
     {≠}{\(\neq\)}1
     {Γ}{\(\Gamma\)}1
                 {Δ}{\(\Delta\)}1
                 {Ω}{\(\Omega\)}1
                 {δ}{\(\delta\)}1
                 {φ}{\(\phi\)}1
                 {τ}{\(\tau\)}1
                 {γ}{\(\gamma\)}1
                 {σ}{\(\sigma\)}1
                 {←}{\(\leftarrow\)}1
                 {□}{\(\Box\)}2
                 {■}{\(\blacksquare\)}2
                 {▷}{\(\triangleright\)}1
                 {⋃}{\(\bigcup\)}2
                 {✓}{\(\checkmark\)}2
                 {⊢}{\(\vdash\)}1
                 {⊨}{\(\vDash\)}1
     {⊣⊢}{\(\provesIff\)}2
                 {→}{\(\to\)}2
                 {∨}{\(\lor\)}2
                 {∧}{\(\land\)}1
                 {∃}{\(\exists\)}1
                 {∀}{\(\forall\)}1
                 {λ}{\(\lambda\)}1
                 {⊑}{\(\sqsubseteq\)}1
                 {∪}{\(\cup\)}1
                 {∖}{\(\setminus\)}1
                 {⊥}{\(\bot\)}1
         {⊤}{\(\top\)}1
                 {≡}{\(\equiv\)}1
                 {∅}{\(\emptyset\)}1
                 {≫}{\(\gg\)}1
                 {↔}{\(\leftrightarrow\)}1
                 {∈}{\(\in\)}1
                 {Φ}{\(\Phi\)}1
         {Ψ}{\(\Psi\)}1
         {-★}{\(-\!\!*\)}2
         {★}{\(*\)}1
         {↦}{\(\mapsto\)}1
         {ö}{\({\ddot{\mathtt o}}\)}1
         {Σ}{\({\Sigma}\)}1
         {Λ}{\({\Lambda}\)}1
b        {Δ1}{\({\Delta_1}\)}2
         {Δ2}{\({\Delta_2}\)}2
         {j1}{\({\mathtt j_1}\)}2
         {j2}{\({\mathtt j_2}\)}2
         {P1}{\({\mathtt P_1}\)}2
         {P2}{\({\mathtt P_2}\)}2
         {_}{\(\_\!\_\)}1
         {⟦}{\([\![\)}1
         {⟧}{\(]\!]\)}1
         {⋅}{\(\mtimes\)}1
         {~}{\(\thicksim\)}1
         {–≻}{\(--\succ\)}2
         {ₑ}{\({}_e\)}1
}


\lstdefinelanguage[]{STLang}[objective]{Caml}
{% general command to set parameter(s)
basicstyle=\footnotesize\ttfamily, % print whole listing small
keywordstyle=\bfseries\color{green!40!black},
morekeywords={cont},
morekeywords=[2]{Some, None, true, false, null},
keywordstyle=[2]\bfseries,
deletekeywords={to, in},
morekeywords=[1]{runST},
morekeywords=[3]{bind, in, !, :=},
keywordstyle=[3]\bfseries\color{blue!70!black},
identifierstyle=, % nothing happens
commentstyle=\color{green!60!black}, % white comments
stringstyle=\ttfamily, % typewriter type for strings
showstringspaces=false, % no special string spaces
numberstyle=\tiny,
stepnumber=1,
numbersep=5pt,
escapeinside={(*@}{@*)},
mathescape=true,
literate={fun}{{$\lambda$}}1%
         {lin}{{\bfseries \textcolor{green!40!black}{in}}}2%
}

\lstdefinelanguage[]{MyHaskell}[]{Haskell}
{% general command to set parameter(s)
basicstyle=, basicstyle=\footnotesize\ttfamily,
keywordstyle=\bfseries\color{green!40!black},
morekeywords=[1]{>>=},
morekeywords=[2]{runST},
morekeywords=[2]{newSTRef, readSTRef, writeSTRef},
keywordstyle=[2]\bfseries\color{blue!70!black},
numberstyle=\tiny,
literate={tau}{{$\tau$}}1%
         {rho}{{$\rho$}}1%
         {gamma}{{$\gamma$}}1%
         {alpha}{{$\alpha$}}1%
         {beta}{{$\beta$}}1%
         {forall}{{$\forall$}}1%
         {->}{{$\to$}}2%
         {$$}{{\$}}2%
}


\newcommand{\Name}[1]{\textrm{{#1}}}
\newcommand{\Coq}{\Name{Coq}}
\newcommand{\STLC}{\Name{STLC}}
\newcommand{\OCaml}{\Name{OCaml}}
\newcommand{\Rust}{\Name{Rust}}
\newcommand{\Haskell}{\Name{Haskell}}
\newcommand{\ML}{\Name{ML}}
\newcommand{\ala}{\textit{\`a la}\xspace}
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\etal}{\emph{et~al.}\xspace}
\newcommand{\wrt}{w.r.t.~}
\newcommand{\etc}{etc.\xspace}
\newcommand{\cf}{\textit{cf.}}
\newcommand{\Ie}{\textit{I.e.,}}
\newcommand{\defacto}{\textit{de facto}}
\newcommand{\viceversa}{\textit{vice versa}}
\newcommand{\Iris}{Iris}
\newcommand{\CaReSL}{CaReSL}
\newcommand{\FCSL}{FCSL}
\newcommand{\iCAP}{iCAP}
\newcommand{\Autosubst}{Autosubst}
\newcommand{\ST}{\Name{ST}}
\newcommand{\ICtriple}{IC-triple}
\newcommand{\ICName}{IC}
\newcommand{\ICLongName}{If-Convergent}

\newcommand{\systemF}{System~\(\mathsf{F}\)}
\newcommand{\IPM}{\textsf{IPM}}

\newcommand{\provesCoq}{\mathrel{\vdash_{\mbox{\!\Coq{}}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCRETE LANGUAGE SYNTAX AND SEMANTICS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\textlang}[1]{\texttt{#1}}
\newcommand{\langkw}[1]{\textlang{\color{blue} #1}}
\newcommand{\lvar}[1]{\textit{#1}} % Yes, this makes language-level variables look like logic-level variables. but we still distinguish locally bound variables from global definitions.
\newcommand{\lvarA}{\lvar{\var}}
\newcommand{\lvarB}{\lvar{\varB}}
\newcommand{\lvarC}{\lvar{\varC}}

\newcommand{\loc}{\ell}

\def\Let#1=#2in{\langkw{let} \spac #1 \mathrel{=} #2 \spac \langkw{in} \spac}
\def\If#1then{\langkw{if} \spac #1 \spac \langkw{then} \spac}
\def\Else{\spac\langkw{else} \spac}
\def\Ref(#1){\langkw{ref}(#1)}
\def\Rec#1 #2={\langkw{rec}\spac{#1}({#2}) \mathrel{=} }
\def\Fun #1.{\lambda\spac{#1}.\spac}
\def\Skip{\langkw{skip}}
\def\Assert{\langkw{assert}}
\newcommand\Inj[1]{\langkw{inj}_{#1}\spac}
\newcommand\Proj[1]{\pi_{#1}\spac}
\def\True{\langkw{true}}
\def\False{\langkw{false}}
\def\Match#1with#2=>#3|#4=>#5end{\langkw{match}\spac#1\spac\langkw{with}\spac#2\Ra#3\mid#4\Ra#5\spac\langkw{end}}
\def\MatchML#1with#2=>#3|#4=>#5end#6{{\arraycolsep=1.4pt\begin{array}[t]{rll}%
    \multicolumn{3}{l}{\langkw{match}\spac#1\spac\langkw{with}}\\%
    &#2&\Ra#3\\|&#4&\Ra#5\\%
    \multicolumn{3}{l}{\langkw{end}#6}%
  \end{array}}}
\def\MatchMLL#1with#2=>#3|#4=>#5|#6=>#7end#8{{\arraycolsep=1.4pt\begin{array}[t]{rll}%
    \multicolumn{3}{l}{\langkw{match}\spac#1\spac\langkw{with}}\\%
    &#2&\Ra#3\\|&#4&\Ra#5\\|&#6&\Ra#7\\%
    \multicolumn{3}{l}{\langkw{end}#8}%
  \end{array}}}
\def\MatchS#1with#2=>#3end{
  \langkw{match}\spac#1\spac\langkw{with}\spac#2\Ra#3\spac\langkw{end}}
\newcommand\CAS{\langkw{CAS}}
\newcommand*\Fork[1]{\langkw{fork}\spac\set{#1}}
\newcommand*\RunST[1]{\langkw{runST}\spac\set{#1}}
\newcommand*\JustRunST{\langkw{runST}\spac}
\newcommand\deref{\mathop{!}}
\let\gets\leftarrow

\newcommand{\fold}{\langkw{fold}\spac}
\newcommand{\unfold}{\langkw{unfold}\spac}

\newcommand{\Op}[1]{\mathrel{#1}}

\newcommand{\binop}{\circledcirc}
\newcommand{\Plus}{\Op{+}}
\newcommand{\Minus}{\Op{-}}
\newcommand{\Mult}{\Op{*}}
\newcommand{\Eq}{\Op{=}}
\newcommand{\Lt}{\Op{<}}

\newcommand{\TT}{()}

\def\Bind#1in{\langkw{bind} \spac #1 \spac \langkw{in} \spac}
\newcommand{\return}{\langkw{return}\spac}

% types
\newcommand{\tvar}{X}
\newcommand{\tvarB}{Y}
\newcommand{\TVar}{\textdom{Tvar}}
\newcommand{\TLam}{\Lambda\spac}

\newcommand{\typ}{\tau}
\newcommand{\Typ}{\textdom{Types}}
\newcommand{\typB}{\sigma}
\newcommand{\Treg}{\rho}
\newcommand{\Tunit}{\mathbf{1}}
\newcommand{\Tbool}{\mathbb{B}}
%% \newcommand{\Tnat}{\mathbb{N}}
\newcommand{\Tint}{\mathbb{Z}}
\newcommand{\Tarr}{\ra}
\def\Tall #1.{\forall #1.\spac}%
\def\Tmu #1.{\mu #1.\spac}%
\def\Tref(#1){\textlang{ref}(#1)}%
\newcommand{\TST}[2]{\textlang{ST}\ #1\ #2}%
\newcommand{\TSTRef}[2]{\textlang{STRef}\ #1\ #2}%
\newcommand{\Refeq}{==}

\newcommand{\Tenv}{\Xi}
\newcommand{\env}{\Gamma}
\newcommand{\Henv}{\Sigma}
%\newcommand{\typedh}[5]{#1 ~|~ #2 ~|~ #3 \vdash #4 : #5}
\newcommand{\typed}[4]{#1 ~|~ #2 \vdash #3 : #4}
\newcommand{\ctxtyped}[7]{#1 : (#2~|~ #3; #4) \rightsquigarrow (#5~|~ #6; #7)}
\newcommand{\semtyped}[4]{#1 ~|~ #2 \vDash #3 : #4}
\newcommand{\semtypednice}[4]{#3 : #4}

%evaluation context
\newcommand{\elctx}{K}
%well-typed contexts
\newcommand{\wctx}{C}

%effectful reduction
\newcommand{\effstep}{\leadsto}

%heap
\newcommand{\heap}{h}
\newcommand{\stateinterp}{\mathit{Heap}}


\newcommand{\excl}{\textlog{excl}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lists
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\app}{\mathrel{+\!+}}
\newcommand{\reverse}{\mathsf{reverse}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ordinary Logical relations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\OLR}[3]{\mathit{OLR}(#1, #2)\{#3\}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Logical relations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\semenv}{\Delta}
\newcommand{\semVtype}[3]{\llbracket #2 \rrbracket_{#3} } % #1 \vdash
\newcommand{\semGtype}[3]{{\mathcal{G}}\llbracket #2 \rrbracket_{#3} } % #1 \vdash
\newcommand{\semE}[1]{\mathcal{E}\;\!#1\;\!}
\newcommand{\semEtype}[3]{\semE{\llbracket #2 \rrbracket_{#3}}} % #1 \vdash

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%free variables
\newcommand{\FV}{\mathsf{FV}}
%configuration
\newcommand{\cfgg}{\rho}
%logically related
\newcommand{\preclog}{\preceq_{\mathsf{log}}}
%contextual refinement
\newcommand{\precctx}{\preceq_{\mathsf{ctx}}}
%contextual equality
\newcommand{\eqctx}{\approx_{\mathsf{ctx}}}
%monoid names
\newcommand{\Gname}{\textdom{Names}}
%monoid names
\newcommand{\Monoid}{\textdom{Monoid}}
%general reduction
\newcommand{\genstep}{\rightharpoonup}
%finite
\newcommand{\finite}{\textlog{finite}}
%finite set
\newcommand{\finset}{\textlog{finset}}
%validity
\newcommand{\valid}{\checkmark}
\newcommand{\invalid}{\valid\!\!\!\!\!\setminus}
%iRes
\newcommand{\iRes}{\textdom{iRes}}


%weakest preconditions with a generalized monoid name like IC
\NewDocumentCommand\genwpre{m m O{} m}%
  {\textlog{wp}^{#1}_{#3}\spac#2\spac{\left\{#4\right\}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Iris extensions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\exceptzero}{\Diamond}
\newcommand{\plain}[1]{\textlog{plain}(#1)}
\newcommand{\savedPred}[2]{#1 \Mapsto #2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       If Convergent (similar to weakest precondition)        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\NewDocumentCommand\IC{m m O{} m}%
  {\textlog{IC}^{#1}_{#3}\spac#2\spac{\left\{\hspace*{-0.2em}\left|#4\right|\hspace*{-0.2em}\right\}}}

% if convergent triple
\newcommand{\ICtr}[4]{\left\{\hspace*{-0.2em}\left| \:\!#2\:\! \right|\hspace*{-0.2em}\right\} #3 \left\{\hspace*{-0.2em}\left| \:\!#4\:\! \right|\hspace*{-0.2em}\right\}_{#1}}
\newcommand{\ICtrV}[4]{\begin{aligned}[t] & \left\{\hspace*{-0.2em}\left| \:\!#2\:\! \right|\hspace*{-0.2em}\right\}\\ & #3 \\& \left\{\hspace*{-0.2em}\left| \:\!#4\:\! \right|\hspace*{-0.2em}\right\}_{#1}\end{aligned}}

\newcommand{\redsto}[3]{#1\Downarrow^{#2}_{#3}}

% future
\NewDocumentCommand \fvs {m O{}} {\mathord{\vsGen[#2]{{\mid\kern-0.5ex\gg\!\!\!\{#1\}\!\!\!\equiv\!\!\later\kern-0.25ex}}\kern0.2ex}}
\NewDocumentCommand \wfvs {m O{}} {\;\mathord{\vsGen[#2]{{\kern-0.5ex\gg\kern-1.25ex\{#1\}\kern-1.25ex\equiv\kern-1ex\smash{\raisebox{-0.2ex}{\scalerel*{\vphantom-\ast}{4}}}\kern-0.25ex}}\kern0.2ex}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Helper macros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% FIXME find better name etc...
\newcommand{\weirdtriple}[3]{\big\{ #1 \big\}\: #2 \:\big\{ #3 \big\}_{\gnameh,\gnameh'}}
\newcommand{\weirdtripleV}[3]{\begin{aligned}[t]
    & \big\{ #1 \big\}\\ & \quad #2 \\ & \big\{ #3 \big\}_{\gname,\gnameh'} \end{aligned}}

\newcommand{\gnamebij}{\gname_{\!\textsl{bij}}}
\newcommand{\gnamerel}{\gname_{\!\textsl{rel}}}
\newcommand{\gnamereg}{\gname_{\!\textsl{reg}}}
\newcommand{\gnamepred}{\gname_{\!\textsl{pred}}}
\newcommand{\gnameh}{\gname_{h}}

\newcommand{\isreg}{\textsf{isRgn}}
\newcommand{\semreg}{r}
\newcommand{\regbij}{\textsf{bij}}
\newcommand{\regrel}{\textsf{rel}}

\newcommand{\stdsemtyped}[3]{\semtyped{\Tenv}{\env}{#1 \preclog #2}{#3}}
\newcommand{\simplesemtyped}[2]{\semtyped{\Tenv}{\env}{#1 \preclog #1'}{#2}}
\newcommand{\stdErel}[3]{\semEtype{}{\Tenv \vdash #1}{\semenv}(#2, #3)}
\newcommand{\substErel}[3]{\semEtype{}{\Tenv \vdash #1}{\semenv}(\overline{#2}, \overline{#3})}
\newcommand{\ssErel}[2]{\semEtype{}{\Tenv \vdash #1}{\semenv}(\overline{#2}, \overline{#2'})}
\newcommand{\stdVrel}[3]{\semVtype{}{\Tenv \vdash #1}{\semenv}(#2, #3)}
\newcommand{\substVrel}[3]{\semVtype{}{\Tenv \vdash #1}{\semenv}(\overline{#2}, \overline{#3})}
\newcommand{\ssVrel}[2]{\semVtype{}{\Tenv \vdash #1}{\semenv}(\overline{#2}, \overline{#2'})}

\newcommand{\fracmapsto}{\fmapsto[\mathrm{-}]}
\newcommand{\spatctx}{-------------\{ spatial resources \} -------------}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% referring to lemmas, theorems, etc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\lemref}[1]{Lemma~\ref{#1}}
\newcommand{\thmref}[1]{Theorem~\ref{#1}}
\newcommand{\defref}[1]{Definition~\ref{#1}}
\newcommand{\conjref}[1]{Conjecture~\ref{#1}}
\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\sectref}[1]{\S\ref{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SPACING AND OTHER STUFF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\negquad}{\mkern-18mu}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Misc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\fpfnsmall}{\rightharpoonup^{\textrm{fin}}}


\newcommand{\rRange}{\textdom{Hrel}}
\newcommand{\gRange}{\textdom{Hbij}}

\newcommand{\inferref}[1]{\textsc{\ref{#1}}}
\newcommand{\Pfin}{\mathcal{P}_{\text{fin}}}

\newcommand{\reg}{r}
\newcommand{\heapp}[2]{heap_{#1}(#2)}
