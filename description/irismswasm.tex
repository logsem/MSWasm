\documentclass[acmsmall,screen]{acmart}\settopmatter{}
%\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsfonts}

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{natbib}
%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\usepackage{includes}
\usepackage{todonotes}
\usepackage{iris}
\usepackage{xcolor} 
\usepackage{mathtools}
\usepackage{amsmath} 
\usepackage{csquotes}
\usepackage{mathrsfs}
\usepackage{placeins}
\usepackage[inline]{enumitem}
\usepackage{rotating}
\usepackage{multirow}
\usepackage{prftree}
\usepackage{graphicx}



%% Other packages

% for multi-file teX projects
\usepackage{standalone}
\usepackage{import}

%% For clever references: \cref{...}
\usepackage[capitalize]{cleveref}

%% more fonts
\usepackage{ dsfont }

%% proof trees
\usepackage{bussproofs}

%% for wrapping text around figures
\usepackage{wrapfig}

\author{Maxime Legoupil}
\title{Certifying MSWasm in Coq}
\date{\today}

\input{macros}
\hyphenation{WebAssembly}

 

\begin{document}

\maketitle

\wasm~\cite{wasm} is a compact and portable bytecode designed to be an appropriate compilation target for versatile usage on the web. Its design focuses on compactness, portability, and on safety features like module encapsulation. Within each \wasm module, however, all bets are off when it comes to memory access, as reads and writes are performed using raw \xxWithirtytwo integers as addresses and thus all accesses performed within the module are permitted. \wasm's encapsulation properties are inherently coarse-grained: all that they guarantee is that adversary modules can only interact with this module's memory via the objects it explicitely exports. If the module explicitely declares that it wishes to export its memory, any adversary can import it and perform reads and writes freely; else adversary modules are restricted to performing function calls to functions explicitely exported.

\mswasm~\cite{mswasm} is a proposal of a modification to \wasm's operational semantics, where memory would be accessed not by a raw \xxWithirtytwo integer as an address, but rather via use of a \emph{handle}, which is a pointer enriched with meta-information such as bounds that this pointer is allowed to access and an ID that allows the machine that runs \mswasm to check that the handle hasn't yet been freed. Importantly, handles are unforgeable, so the only way to access memory at a given location is to have been given the handle for that location by the entity that created that handle via memory allocation. In other settings, handles (also refered to as \emph{capabilities}) have already been shown~\cite{capabilities} to be a reliable way of obtaining fine-grained memory safety properties, which makes \mswasm a promising project that could bring additional fine-grained safety to the existing coarse-grained safety properties of \wasm.

In this document, we present \irismswasm, a program logic for \mswasm in the Coq proof assistant, defined on top of the Iris separation logic~\cite{iris}. This allows us to prove numerous properties of \mswasm in the Coq proof assistant, and showcase \mswasm's safety properties on small examples making use of the new features. We build \irismswasm on top of \iriswasm~\cite{iriswasm}, an existing mechanisation of simple \wasm in Coq and Iris. We provide examples contrasting what is obtainable in simple \wasm with more sophisticated examples allowed by \mswasm.

In the rest of this document, we provide an overview of the \wasm and \mswasm operational semantics, we describe the program logic defined by \irismswasm, and we illustrate our work with examples that showcase the strengths of \mswasm.


\section{The semantics of \mswasm}

In this section, we present the operational semantics of \mswasm. We begin by giving an overview of the operational semantics of plain \wasm. If this overview is too succinct, we refer the interested reader to existing more detailed documentation~\cite{wasm}. In \S\ref{sec:memory}, we present in detail the point of separation between \wasm and \mswasm. We will be using the notations of \citet{iriswasm} (which are quite similar to those of~\citet{wasm}), and the semantics we present here is the one they introduce, which is identical in all but one point (see \S\ref{sec:control}) to the semantics defined by the standard~\cite{wasm}.

\subsection{A stack-based language}

At its core, \wasm is a stack-based language. The state of execution is represented by a triplet \( (S, F, \V{es}) \): a \emph{store}, a \emph{frame} and a stack of \emph{administrative instructions}.\footnote{to avoid confusion with the separating conjuction \( \ast \) used in separation logic, we denote by \( \V{es} \) a list of \( e \), rather than the \( e^\ast \) notation used in the original \wasm documentation~\cite{wasm}.}
We will progressively introduce the meaning of these; a full account of the syntax can be found in Figure~\ref{fig:wasmast}. For now, we focus on the third component, the stack of administrative instructions, since the simplest \wasm instructions do not make use of or modify the store or frame.

The stack of administrative instructions represents the \wasm code being executed. Administrative instructions are \emph{basic instructions}, i.e. instructions that can appear in a \wasm program, enriched with a number of extra constructs that appear only during execution, and which we shall introduce later when relevant. At the beginning of execution, the stack \( \V{es} \) represents the full \wasm program, and as the execution is carried out, the first non-value instructions in the stack are executed one by one, and their results are put back into the same stack. Let us consider the simple case of a binary operation, say, \xxWithirtytwo addition:
\[ (S,F, [\xxWithirtytwo.\xxWconst~c_1;~\xxWithirtytwo.\xxWconst~c_2;~\xxWithirtytwo.\xxWadd]) \hookrightarrow (S,F, [\xxWithirtytwo.\xxWconst~(c_1 + c_2)]) \]
In order for this rule to be applicable in the context of a larger program in which the addition is only the first instruction, \wasm comes with a frame rule that allows for execution inside a context:
\[ \inferrule{(S,F,\V{es})\hookrightarrow(S',F',\V{es}')}{(S,F, \V{vs}\cat\V{es}\cat\V{es_2})\hookrightarrow(S',F',\V{vs}\cat\V{es}'\cat\V{es}_2)} \]
Note that when we write \V{vs}, we implicitely mean \emph{values} as defined in Figure~\ref{fig:wasmast}. We will later introduce a more general notion of context and a stronger frame rule.

\wasm defines 4 simple types for its values: \xxWithirtytwo, \xxWisixtyfour, \xxWfthirtytwo and \xxWfsixtyfour, to which \mswasm adds one extra type \xxWhandle which we discuss in \S\ref{sec:memory}. \wasm defines a simple notion of typing for all instructions, of the form \( \KK{insn}\colon\V{t1s}\to\V{t2s} \) where \( \V{t1s} \) are the types of the values consumed by the instruction and \( \V{t2s} \) are the types of the values produced. For instance, \( \xxWithirtytwo.\xxWadd\colon[\xxWithirtytwo;\xxWithirtytwo]\to[\xxWithirtytwo] \). We will not enter farther into details about this type system and refer the interested reader to existing documentation~\cite{wasm}.

Aside for addition shown above, \wasm defines other binary operations on its four base types, as well as comparison and conversion operations. There is also a \xxWselect instruction (\( [a;b;c;\xxWselect] \) should be read as ``if \( a \) then \( b \) else \( c \)'') and other trivial operations such as \xxWdrop, \xxWnop and \xxWunreachable. All of these have corresponding operational semantics rules that mirror intuition.

Lastly, let us mention local and global variables. Access to both of these is done through integer indices \( i \) rather than variable names. To explain where their values are stored, let us take a closer look at the frame \( F \) in the state of a \wasm execution:
\[  F::=\{ \xxfield{locs} : \V{vs}, \quad \xxfield{inst} : \V{inst} ~ \} \]
The first component \xxfield{locs} is a list of values representing the values of the local variables, enabling reading and writing local variables.

For global variables, the process is a little more involved. The values of global variables of the current module are located in the store \( S \), together with the global variables of all other modules that have been instantiated so far. This is in order to allow a module to export some its global variables, and import those of other modules. One of the components of the store \( S \) is a list of global variable instances (metadata on mutability together with the variable's value). In order to know what index in that list correspond the \( i-\)th global variable of the current module, one uses the second component of the frame \( F \): the \emph{instance} \( \xxfield{inst} \). This object contains a field \xxfield{globs} which is a list of indices: the \( i-\)th index in that list is the location in the store of the wanted global variable. Thus we have the rule \[ \inferrule{F.\xxfield{inst}.\xxfield{globs}[i]=k\and S.\xxfield{globs}[k].\xxfield{value} = \V{v}}{(S,F,[\KK{global.get}~i])\hookrightarrow(S,F,[\V{v}])} \]
And a similar rule for \( \KK{global.set} \) albeit with an extra check that the mutability of the variable is allowed. This \emph{indirection} handled by the instance will also be a feature of function calls, memory access, and all other instructions involving exportable features, as those are bookkept in the store together with those of other modules, in order to allow for exports and imports. 



\begin{figure}
  \import{figures/}{wasm-ast}
\caption{\wasm Abstract Syntax in black, and the \mswasm additions in red}
\label{fig:wasmast}
\end{figure}



\subsection{Control flow}
\label{sec:control}

\wasm is somewhat unusual as an assembly-like language in that it features no general jump instruction. The only control flow operations allowed are direct or indirect function calls, and \emph{break} (or \emph{branch}) instructions \( \xxWbr{i} \) which allows to exit a group of instructions enclosed in a \KK{block}, \KK{loop} or \KK{if} instruction. Let us first discuss the latter.

The instruction \( \xxWif~{\V{tf}}~{\V{bs}_t}~{\V{bs}_f} \) takes one argument value from the stack and desugars to either \( \xxWblock~{\V{tf}}~{\V{bs}_t} \) or \( \xxWblock~{\V{tf}}~{\V{bs}_f} \) depending on whether the value was 0. Let us have a closer look at the instructions \( \xxWblock~{\V{tf}}~{\V{bs}} \) and \( \xxWloop~{\V{tf}}~{\V{bs}} \). Here, \V{bs} is the content of the \KK{block} or \KK{loop}, and \V{tf} is the type signature, i.e. \( \V{tf} = \V{t1s}\to\V{t2s} \) where \( \V{t1s} \) is the list of the types that are expected to be on the stack upon entering the \KK{block} or \KK{loop}, and \( \V{t2s} \) is the list of the types that will be on the stack upon exiting. The exact contents of these lists are used for typing, and the operational semantics for \xxWblock and \xxWloop only makes use of the length of these lists.

Both the \xxWblock and \xxWloop instructions take the required number of arguments \( \V{vs} \) from the stack, and execute to the administrative instruction \( \xxWlabel{n}{\V{es}_{cont}}{\V{es}} \), where \( n \) represents the number of values that will exit the \KK{label} if it reaches a break instruction, \( \V{es}_{cont} \) is the \emph{continuation} of the label, i.e. the code to be executed in case a break instruction is met, and finally \( \V{es} \) is the contents of the \KK{label}. \( \V{es} \) is initially equal to \( \V{vs}\cat\V{bs} \); as for the value of \( n \) and \( \V{es}_{cont} \), they depend on whether the original instruction was a \KK{block} or a \KK{loop}. When breaking out of a \KK{block}, the block's execution is done and one carries on with whatever code followed the original \KK{block} instruction, hence \( \V{es}_{cont} = [] \) and \( n \) is the length of \V{t2s}; but when breaking out of a \KK{loop}, the whole original loop is repeated, i.e. \( \V{es}_{cont} = [ \xxWloop{\V{tf}}{\V{bs}} ] \) and \( n \) is the length of \( \V{t1s} \). 

Once the \KK{block} or \KK{loop} has executed to a \KK{label} instruction, the execution continues inside of the \KK{label}, meaning the context rule introduced earlier can now be enriched to executing inside of a \KK{label}. In fact, as \KK{block}s and \KK{loop}s can be nested, resulting in nested \KK{label}s, execution can be carried out under an indefinite amount of nested \KK{labels}. To capture this formally, let us define \emph{lholes}:

\[ \V{lh}_0 ::= \V{vs}\cat[\_]\cat\V{es}\qquad\V{lh}_{k+1}::= \V{vs}\cat\xxWlabel{n}{\V{es}_{cont}}{\V{lh}_k}\cat\V{es} \]

Our frame rule now becomes
\[ \inferrule{(S,F,\V{es})\hookrightarrow(S', F', \V{es}')}{(S,F,\V{lh}_k[\V{es}])\hookrightarrow(S',F',\V{lh}_k[\V{es}'])} \]
Taking \( k=0 \) yields the rule introduced earlier.

Execution continues inside the \KK{label} until either the contents are a list of values, in which case the \KK{label} is exited
\[ (S,F,[\xxWlabel{n}{\V{es}_{cont}}{\V{vs}}])\hookrightarrow(S,F,\V{vs}) \]
or until a break instruction is met. This break instruction \( \xxWbr{i} \) has an integer \( i \) as an immediate argument, indicating how many \KK{labels} should be exited. In that case, the last \( n \) values from the stack are kept, and the continuation code is executed:
\[ \inferrule{k=i \and |\V{vs}|=n}{(S,F,[\xxWlabel{n}{\V{es}_{cont}}{\V{lh}_k(\V{vs}\cat\xxWbr{i})}])\hookrightarrow(S,F,\V{vs}\cat\V{es}_{cont})} \]
Crucially, this requires the index \( i \) of the lhole and of the break instruction to be equal: if \( i > k \), the instruction is stuck and can only be unstuck if placed in a deeper context. If \( i < k \), then the break only breaks out of a smaller amount of \KK{label}s, and one can use the frame rule together with the break rule to show that this reduces to something of the form \( \V{lh}_{k-i}(\V{vs}\cat\V{es}) \).

Aside from \( \xxWbr{i} \), the instructions \( \xxWbrif{i} \) and \( \xxWbrtable~{\V{is}} \) desugar to a \KK{br} instruction according the last value on the stack.


Finally, let us describe the way function calls work in \wasm. Function calls can be to a statically know function with the \xxWcall instruction, or to a dynamically determined function with the \( \KK{call\_indirect} \) instruction. In the first case, the immediate argument \V{i} of instruction \( \xxWcall~\V{i} \) refers to the index of the function to be called, where if a module imports \( k \) functions and defines \( \ell \) ones, the imported functions have indices 0 to \( k - 1 \) and the functions defined in the module have indices \( k \) to \( k + \ell - 1 \), in the order in which they appear. Just like the values of global variables, the closures for the functions are all in the store \( S \) together with the closures for functions defined elsewhere, and the frame \( F \) keeps track of the indirection.

For indirect calls, a table in the store contains indices toward functions closures in the store. The \( \KK{call\_indirect}~\V{i} \) instruction takes one argument from the stack indicating which element of that table is to be called, and the immediate argument \( \V{i} \) refers to the type of the function to be called. Since the store may also contain tables for other modules, the frame \( F \) keeps track of the address of the current module's table in the store.\footnote{in \wasm 1.0, each module can at most have one table, so the frame's \xxfield{tables} field is a list of length at most 1.}

After the computation of the index of the function closure in the store, the way direct and indirect function calls work is identical, so \wasm defines an administrative instruction \( \xxWinvoke~\V{a} \) which represents a call to the closure number \V{a} in the store. Both \xxWcall and \KK{call\_indirect} desugar to this \xxWinvoke instruction:

\[ \inferrule{F.\xxfield{inst}.\xxfield{funcs}[\V{i}]=\V{a}}{(S,F,[\xxWcall~\V{i}])\hookrightarrow(S,F,[\xxWinvoke~\V{a}])} \]


\[
\inferrule{F.\xxfield{inst}.\xxfield{tables}[0]=\V{j}\and S.\xxfield{tabs}[\V{j}].\xxfield{elem}[\V{c}]=\V{a}\and F.\xxfield{inst}.\xxfield{types}[\V{i}] = \V{tf} \and \mathrm{typeof}(S.\xxfield{funcs}[\V{a}])=\V{tf}}{(S,F,[\xxWithirtytwo.\xxWconst~\V{c};\KK{call\_indirect}~\V{i}])\hookrightarrow(S,F,[\xxWinvoke~\V{a}])}
\]

Once reduced to an \xxWinvoke instruction, we can look up the function closure in the store. This closure can have two forms: a \emph{native closure} \( \NCl{\V{tf}}{(\V{inst};\V{ts})}{\V{es}} \) represents a function that has been defined in \wasm (either in this module or in another module from which it was imported), and a \emph{host closure} \( \HCl{\V{tf}}{\V{hidx}} \) represents a function defined outside of \wasm by the host language that embeds it (see~\S\ref{sec:host}). In both cases, the function type is \V{tf}. For a host closure, \V{hidx} is an index used to determine what function to execute. For a native closure, \V{es} represents the \wasm code that is the body of the function, \V{ts} is a list of the types of the function's local variables aside from its arguments, and \V{inst} is the instance in the module that defined the function -- i.e. the context of the closure.

In the case of a native closure, the \xxWinvoke instruction reduces as follows:

\[ \inferrule{S.\xxfield{funcs}[i]=\NCl{\V{ts}_1\to\V{ts}_2}{(\V{inst}; \V{ts})}{\V{es}}\and
  |\V{vs}| = |\V{ts}_1| \and F' = \{ \xxfield{locs} := \V{vs}\cat\KK{zeros}(\V{ts}); \xxfield{inst} := \V{inst} \}
}{(S,F, \V{vs}\cat\xxWinvoke~\V{i})\hookrightarrow(S,F,\xxWlocal{|\V{ts}_2|}{F'}{\xxWblock~([]\to\V{ts}_2)~\V{es}})} \]

An appropriate amount of arguments is taken from the stack; a new frame \( F' \) is created for the execution of the function body; and the function body is place inside a \xxWblock and a \KK{local}. The frame \( F' \) defines the local variables the caller will be able to use: first all arguments of the function, and then local variables declared by the function, initialised to zero. The instance in \( F' \) is \V{inst} from the closure, reflecting that the body will execute within the context from the closure.

Let us now explain what the \KK{local} instruction means. This administrative instruction is used to symbolise a function call being executed, and allows execution of the code inside the instruction to execute with the frame in brackets:

\[ \inferrule{(S,F_1,\V{es})\hookrightarrow(S', F_1', \V{es}')}{(S,F,[\xxWlocal{n}{F_1}{\V{es}}])\hookrightarrow(S',F,[\xxWlocal{n}{F_1'}{\V{es}'}])} \]

Just like for a \KK{label} instruction, the \KK{local} is exited if the code inside is a list of values
\[ (S, F, [\xxWlocal{n}{F_1}{\V{vs}}]) \hookrightarrow (S,F,\V{vs}) \]
or if a \xxWreturn instruction is met. In that case, the subscript \( n \) indicates how many values to take from the stack before exiting. Unlike for break instructions, a \xxWreturn instruction should always target the closest \KK{local}, and thus does not need to take an immediate argument:
\[ \inferrule{|\V{vs}|=n}{(S,F,[\xxWlocal{n}{F_1}{\V{lh}_k(\V{vs}\cat\xxWreturn)}])\hookrightarrow(S,F,\V{vs})} \]

When reducing a native call, the code of the closure is placed inside a \KK{local} and inside a \xxWblock, meaning the programmer may decide to use a \( \xxWbr{i} \) instruction with a carefully chosen \( i \) instead of a \xxWreturn instruction.

Finally, in case of a host closure, the approach of \citet{iriswasm} is to use a specially defined \xxWcallhost administrative instruction:

\[ \inferrule{S.\xxfield{funcs}[i]=\HCl{\V{ts}_1\to\V{ts}_2}{\V{hidx}}\and|\V{ts}_1|=|\V{vs}|}{(S,F,\V{vs}\cat[\xxWinvoke~i])\hookrightarrow(S,F,\xxWcallhost~(\V{ts}_1\to\V{ts}_2)~\V{hidx}~\V{vs})} \]

This differs from the \wasm standard~\cite{wasm} syntactically, but behaves the same way semantically and allows for an easier mechanisation in the Coq proof assistant. The instruction \xxWcallhost is stuck and needs outside intervention to carry on executing. We present this outside intervention in the next section.



\subsection{Coarse-grained encapsulation and module instantiation via host language}
\label{sec:host}

\wasm code is organised in \emph{modules}, which have been formally shown to provide encapsulation~\cite{iriswasm}, as a module can only interact with another module's state via what that module explicitely exports.

A module can declare (or import) a memory and a function table,\footnote{\wasm 2.0 lifts the restriction of only one memory and function table being allowed in each module.} and any number of function types (hence allowing types in \KK{call\_indirect} instructions to be referenced by indexing), global variables and functions. Any function, global variable, memory or function table can be exported if this is specified explicitely. Finally, the module can decide to initialise parts of the memory via the \xxfield{data} directive, parts of the function table via the \xxfield{elem} directive, and can specify a start function to be executed immediately when the module is instantiated.

By \emph{instantiation}, we mean the process by which a module is typechecked, its imports are satisfied, its initial memory and table are created, its initial function is executed, and its exports are prepared for subsequent exports.

This process is crucial for \wasm's modular encapsulation, but cannot be performed by \wasm itself. Instead, \wasm is embedded in another language called the \emph{host language}, which aside from performing instantiation, can access all of the components a \wasm module exports, and thus can read or modify an exported memory or table, or call \wasm functions.

Conversely, \wasm code can call functions defined by the host language, which is what we have called host closures in the previous section, opening up the possibility for reentrancy. In the way we have presented this earlier, it is assumed that the host language can decode an index \V{hidx} into a function, and can thus unstuck a program where the first non-constant on the stack (possibly inside nested \KK{local} or \KK{label} instructions) is a \( \xxWcallhost~\V{ft}~\V{hidx}~\V{vs} \) instruction, which it simply replaces by the return value of the call.

\subsection{Memory access}
\label{sec:memory}

The last features we haven't mentionned are those that relate to memory access. This is where \mswasm departs from \wasm by proposing a novel way to deal with reading and writing to memory.

In \wasm, the \emph{memory} of a module, which we shall call \emph{heap memory} to contrast it later with another memory \mswasm introduces, is an array of raw uninterpreted bytes, that is accessed via \xxWload and \xxWstore instructions that take an \xxWithirtytwo argument from the stack and treat it as an address into memory. The instructions take a type as an immediate argument as to know which encoding or decoding mechanism to apply; two functions \xxWserialise and \xxWdeserialise can be quite naturally defined to encode and decode all four numerical types. The instructions also can take additional information (such as an offset) as an immediate argument to allow for simple pointer arithmetics. We showcase here a simple version of usage of the \xxWload instruction, where the only immediate argument is the type to read.

\[ \inferrule{F.\xxfield{inst}.\xxfield{mems}[0]=\V{i}\and S.\xxfield{mems}[\V{i}][c..c+\mathrm{sizeof}(t)]=\V{bs}\and \xxWdeserialise(t, \V{bs}) =c'}{(S,F,[\xxWithirtytwo.\xxWconst~c;~\xxWload~t])\hookrightarrow(S,F,[t.\xxWconst~c'])} \]

Similarly to global variables and indirect function calls, we look up in the frame which of the memories in the store is this module's one, since the store might keep track of memories of other modules too.\footnote{Just like for the function table, each module can have at most one memory in \wasm 1.0, so the instance's \xxfield{mems} field is a list of length at most 1} 

Here, it is clear that \wasm's encapsulation property is limited to coarse-grained encapsulation at the scale of the module: all bets are off when inside a module, since any function can access any part of the memory. Likewise, if a module decides to export its memory, any other module can import it and read and write to it freely. In a effort to obtain fine-grained encapsulation, \mswasm~\cite{mswasm} proposes using \emph{handles} rather than \xxWithirtytwo addresses. Using handles (also called capabilities) has been shown to provide strong fine-grained encapsulation properties in broader contexts~\cite{capabilities}, so are a good bet to achieve this goal in \wasm.


The new features of \mswasm are represented in red in Figure~\ref{fig:wasmast}. We add an extra type to the four numerical types of \wasm: \xxWhandle, representing a capability. This form of enriched pointer consists of a base address, an offset, a bound, a validity bit and an \xxWid, and is intended to mean a pointer to address \( \xxWbase+\xxWoffset \). The handles are unforgeable and can only be obtained via usage of the \xxWsegalloc instruction which we introduce later. This means that \( \xxWhandle.\xxWconst~h \) can only appear within the execution of code and not in the original program, hence constants are no longer basic instructions in \mswasm, and are instead a new form of administrative instructions. Using non-handle (i.e. numerical) constants is still allowed, and thus we add a new basic instruction \( \V{nt}.\xxWimmediate~c \) has been added. An immediate instruction reduces in one step to a constant of the given value \( c \) and of the numerical type \V{nt}.

When attempting to read or write with a handle, dynamic checks enforce that the offsets that will be read or written are all between 0 and \( \xxWbound \), the validity bit is \xxCtrue, and the handle's \xxWid is still live (we come back to how this last point is checked a few paragraphs below). If that is the case, \xxWsegload and \xxWsegstore instructions are permitted to read and write from the \emph{segment memory}, a new kind of memory that can only be accessed via handles. These instructions take a type as an immediate argument to know how to interpret the bytes in the segment memory.

One subtlety arises from reading handles, which necessitates tagging the bytes to forbid something written as a numerical value to later be read as a handle, which would effectively forge a handle. In that case, \mswasm allows the read but set the validity tag to \xxCfalse. We also restrict reading and writing handles to addresses that are aligned with the length of a handle, in order to disallow writing two handles consecutively in the segment memory, and then attempt to read a handle which would start midway through the first. We abstract over what mechanism is used to serialise a handle into a byte representation, and simply assume we have two functions \xxWserialisehandle and \xxWdeserialisehandle (which we use to complete the \xxWserialise and \xxWdeserialise functions with the new \xxWhandle type) as well as one constant \xxWhandlesize such that \xxWserialisehandle and \xxWdeserialisehandle are inverses to one another, \( \xxWhandlesize > 0 \) and the output value of \xxWserialisehandle is always a list of bytes of length \xxWhandlesize.

Previous works on \mswasm~\cite{mswasm} limit themselves to the case of one single module. In \irismswasm, we generalise to the full module system. Rather than operating as for heap memory with several memories in the store and the frame remembering which memory each module uses, we choose to only keep one segment memory present in the store, and that segment memory is shared by all modules. This helps to underline that the encapsulation properties no longer stem from \wasm's module system, but from the handles themselves providing fine-grained memory safety. As a result, the frame doesn't need to keep track of any additional information in order to accomodate \mswasm.

To keep track of live handles, we use an \emph{allocator}. \citet{mswasm} does not go into much detail about how this allocator should be implemented, only stating it should allow for the definition of allocation and freeing functions that have some properties which they only define intuitively. In \irismswasm, we define the allocator as a map from the space of handle \xxWid{}s to pairs of integers representing the handle's original base address and bound.

This means allocating and freeing handles can be defined simply by adding and removing from this map, and these operations can be performed with the \xxWsegalloc and \xxWsegfree instructions. Basing ourselves on \citet{mswasm}, we impose several conditions on the handle to be freed: its \xxfield{base} field must be the original address the handle got allocated as (i.e. the handle cannot have been sliced, see next paragraph), its offset must be zero, and its validity bit must be \xxCtrue. %As for allocation, 

Finally, two operations on handles are defined to allow for pointer arithmetics and restrictions on the accessible area of a handle: \xxWhandleadd and \xxWslice. As is custom when working with capabilities, these instructions are allowed to create corrupt handles with an \xxWoffset pointing outside the handle's allowed range; an exception is only raised if one later tries to read or write using this handle. This is to reflect real-world behaviour where a forbidden pointer might often be created but never used e.g. right before a loop is exited.

The operational semantics rules for all these operations are presented in Figure~\ref{fig:segsemantics}. These rules are almost identical to those of \citet{mswasm}. The changes brought by \irismswasm displayed in red and are described in the next paragraph. Not displayed in the figure are all the failure rules, which simply state that when at least one of the premises isn't met, \xxWsegload, \xxWsegstore, \xxWsegfree, \xxWhandleadd and \xxWslice all reduce to \xxWtrap.
We also provide in Figure~\ref{fig:helpers} our own definitions for the \( \xxsalloc{\V{sinst}}{\V{ainst}}{\V{addr}}{\V{off}}{\V{id}}{\V{sinst}'}{\V{ainst}'} \) and \( \xxsfree{\V{sinst}}{\V{ainst}}{\V{addr}}{\V{bound}}{\V{id}}{\V{sinst}'}{\V{ainst}'} \) predicates used in the allocation and freeing rules, as these are not defined by \citet{mswasm}.

The changes \irismswasm brings to \mswasm are:
\begin{itemize}
\item \irismswasm introduces a second operational semantics rule for \xxWsegalloc, allowing the allocation to non-deterministically fail to represent realistic machine behaviour. 
\item An extra check is performed on the \xxWhandleadd operation to check that the new \xxWoffset is non-negative; this allows us to use unsigned integers to represent these and thereby avoid dividing our maximum integer by two just for half the values to be unusable anyway. This means that the check for non-negativity of \xxWoffset in the rules for \xxWsegload and \xxWsegstore are now vacuous and can be removed
\item An extra check is performed in the rule for \xxWsegfree to enforce that the handle's base and bound correspond exactly to the value pair that the handle's \xxWid points to in the allocator. \mswasm already enforced this for the base, but we add the requirement for the bound, as this makes it possible to derive stronger results for robust safety: if I want to free a handle, I need to be able to provide all of the resources that were allocated when this handle was created. In other words, a handle that was nontrivially sliced cannot be freed -- even if only its bound was sliced off
\item Two minor typos from the original work~\cite{mswasm} were corrected: the higher bound check in the \xxWsegload and \xxWsegstore rules should be a \( \leq \) instead of a \( < \) (else when allocating \( n \) spaces of memory, one cannot read a value that has size \( n \)), and the bound check for the second component of \xxWslice should be stricter since the bound is an offset from the base rather than an address, i.e. if I change the base, I need to compensate at least equally as much on the bound.
\end{itemize}
%. These are corrections for minor typos in the original work defining \mswasm, one extra check on the \xxWhandleadd operation and 


\import{figures/}{segsemantics}







\section{\irismswasm: a program logic for \mswasm}

\section{Examples}




\bibliography{irismswasm}
\end{document}
